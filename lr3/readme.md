МИНИCTEPCTBO НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ АВТОНОМНОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ

«СЕВЕРО-КАВКАЗСКИЙ ФЕДЕРАЛЬНЫЙ УНИВЕРСИТЕТ»

**Департамент цифровых, робототехнических систем и электроники**

ОТЧЕТ ПО ЛАБОРАТОРНОЙ РАБОТЕ № 3

ДИСЦИПЛИНЫ «Параллельные вычисления»

НА ТЕМУ:

«Параллельная реализация метода сопряжённых градиентов для решения СЛАУ»

**Выполнил:**

студент группы ПИН-м-о-25-1

ФИО Джабраилов Тимур Султанович

Проверил: старший преподаватель департамента цифровых, робототехнических систем и электроники института перспективной инженерии Щёголев А. А.

Ставрополь, 2024

Для начала необходимо реализовать полностью параллельную версию программы вычисления решения СЛАУ.

![](/lr3/static/1.png)

Рисунок 1 - основная часть решения программы параллельного решения СЛАУ

Функция conjugate_gradient_method реализована следующим образом.

![](/lr3/static/2.png)

Рисунок 2 - реализация функции conjugate_gradient_method

Далее для верификации корректности результата необходимо реализовать последовательную программу

![](/lr3/static/3.png)

Рисунок 3 - реализация верификации корректности с помощью последовательной реализации и вычисления ошибки по L2-норме

Далее, при выполнении программы можно заметить, что ошибка является очень маленькой, следовательно, программа выполняется корректно.

![](/lr3/static/4.png)

Рисунок 4 - запуск параллельной программы с верификацией на 4-х процессах

Далее необходимо реализовать упрощённую версию программы, где вспомогательные векторы не будут вычисляться параллельно, а их вычисление будет дублироваться.

![](/lr3/static/5.png)

Рисунок 5 - реализация упрощённой версии вычисления СЛАУ

![](/lr3/static/6.png)

Рисунок 6 - метод conjugate_gradient_method упрощённой реализации параллельного вычисления программы

Как можно заметить на рисунке 6, реализация стала гораздо короче. При запуске этой программы с верификацией результата можно заметить, что ошибка также остаётся довольно маленькой, следовательно, результат вычислен правильно.

![](/lr3/static/7.png)

Рисунок 7 - запуск упрощённой реализации на 6-ти процессах

Далее необходимо сравнить производительность выполнения данных 2-х реализаций. Для этого запишем результаты выполнения обоих программ в файл.

![](/lr3/static/8.png)

Рисунок 8 - реализация вставки результатов реализации в csv файл

Далее запустим обе программы на разных количествах процессов.

![](/lr3/static/9.png)

Рисунок 9 - результат длительности выполнения обеих программ по отношению к кол-ву процессов

![](/lr3/static/10.png)

Рисунок 10 - графики ускорения и эффективности

Как можно заметить по результатам тестирования оба варианта программы плохо масштабируются при увеличении числа процессов, но лучше себя показывает упрощённая версия из-за того, что в ней меньше накладных расходов на коммуникацию между процессами:

- для timings_slay_simplified.csv лучший момент - примерно 4 процесса (время минимальное примерно 0.0355 ceкунд). При 8, 16 и 32 процессах время растёт - параллельность не даёт выигрыша.
- для timings_slay.csv поведение ещё хуже: при 32 процессах время взлетает до 20 секунд (катастрофическое падение производительности) - очевидно либо переполнение/конфликт/ошибка, либо сильная конкуренция.

Связанно это в первую очередь с тем, что матрица, на которой производится тестирование обладает размером 200 на 300, что не является достаточно большим размером для того, чтобы параллелизм имел смысл.

Далее необходимо добавить регуляризация результата по Тихонову, а также выход из вычислений на основании размера ошибки ||r|| < epsilon.

![](/lr3/static/11.png)

Рисунок 11 - функция conjugate_gradient_method с добавленной регуляризацией и ранней остановкой на основании ошибки

При запуске данной программы можно убедится с правильности её выполнения

![](/lr3/static/12.png)

Рисунок 12 - запуск усовершенствованной версии с помощью 4-х процессов

На данном рисунке можно заметить маленькую степень ошибки 2 \* 10^-3, что указывает на правильность результата.

**Вывод**

В ходе данной лабораторной работы были получены навыки решения СЛАУ Ax = b с помощью итеративного метода сопряженных градиентов, а также были проанализированы разные реализации программы с разной степенью параллелизма вычислений.